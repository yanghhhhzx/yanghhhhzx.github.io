# Redis进阶
我的个人Redis学习笔记（一部分），但是因为之前并没有打算发，所以写得内容不多。
# Redis集群
单节点Redis的并发能力是有上限的，通过集群的方式可以提高在遇到大量线程去访问redis时候的能力。

## 主从集群

分节点的数据会自动与主节点进行同步，主节点只能进行写，从节点只能读。多个分节点可以减少单节点的读的压力。

### 实现方式
如果是在在Docker中，需要先连接到分节点的bash，然后执行命令`slaveof 主节点ip 主节点端口`，就形成主从关系了。

### 主从同步的原理
1. 在从节点连接主节点时，判断是否是第一次连接
2. 如果是第一次连接就全量同步（把信息全部同步过去）
3. 否则则增量同步（根据之前的记录增加没有的）

判断是否是第一次链接的方法：Replication Id：简称replid，是数据集的标记。当replid与主节点不一致，则为第一次。

#### 增量同步：
offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大
1. 主节点会把所有执行过的命令记录在repl_baklog
2. 如果offset不一致，就执行repl_baklog中的命令
repl_baklog是环形的，到积累到一定规模后会从头覆盖，如果从节点宕机太久，容易导致主节点命令存了一圈覆盖的节点包含未执行的，这时候就只能重新全量同步了。为了避免这种情况可以扩大repl_baklog。

### 哨兵机制

#### 节点检测是否下线
心跳机制检查节点是否故障，但是不只有一个哨兵，有哨兵集群，一般要有超过一定数量的哨兵认证，才认为该节点是客观下线了。

#### master下线，选取新的master
选取新的master：
1. 断开时间超过指定值的不选（即便你优先基更高）。
2. 可以手动给每个节点设置优先级，默认都一样。
3. 如果一样就选取其中数据最新的，就是比较offset哪个更大。
4. 如果还一样就根据id。

#### 执行改master命令
1. 发现master客观下线的那一个哨兵会成为leader，他会负责发送改master的命令：
2. 给备选节点发送slaveof no one，成为master
3. 其他节点发送slaveof 备选节点ip 端口
4. 如果之前的节点苏醒，那么他也会成为从节点。

## 分片集群
就是多个主节点，每个主节点都能写，提高了写的并发能力。每个主节点可以互相充当别人的哨兵。

# 分布式锁
## 为什么一般用Redis来做分布式锁？而不是用Mysql？
我认为是这样的：分布式锁需要被进程频繁得去获取，也就是需要频繁读写，单个数据的持续时间不长，一般都是短暂存在的数据，而Redis高速的特性就非常适合这个场景。而如果用MYsql则会导致频繁的磁盘IO，完全没有必要而且性能也比Redis差。
## 实现方式
redission实现的分布式锁，其底层是基于redis lua脚本和setnx。nx就是判断值是否存在，若存在，则失败，若不存在则set成功。

## 看门狗
解决锁的管理问题：当一个线程占用分布式锁时间超出分配的时间时，可以帮他续航

## redission是可重入的

## reids集群部署时的问题
Redis不集群部署，往往会导致可用性下降。但是就是是集群部署，其实也无法保证绝对主从一致问题，因为可能会主节点在拿到锁的时候，刚刚好宕机，从节点来不及获取到主节点的锁。（这一点感觉更应该放到Redis的集群部署上面）。

## 红锁
就是在获取锁是，需要向多个Redis节点申请锁，**至少要超过一半节点**，原因以及机制如下：

因为分布式锁的机制就是不希望多个进程同时获取到锁，如果需要的节点树低于一般，比如1/3，就可能出现一个进程获取了1/3，另外的进程又在另外的2/3里面还可以获取到1/3，就无法实现锁了。

但是红锁是强以来每个Redis节点的时间。这就会导致可能某些节点时间跑得更快，导致提前释放了。所以我认为一个需要同时获取更多得Redis节点，而不宜接近50%，比如可以获取70%。但是也不宜太高，因为会可能很多出现Redis节点本身故障，导致无法获取到锁。且性能下降。

采用红锁得方式，其实本身性能也不好，建议可以使用其他方式实现得分布式锁。

# 缓存相关问题
## 1. 缓存穿透：是查找redis、mysql中都没有的空数据。这样就不会保存在redis，导致每次都查sql。
解决方法：1. 布隆。2. 把null存进redis（消耗内存）
## 2. 缓存击穿：是指某个热点数据到期
解决方法有两种： 
1. 互斥锁。（拿到互斥锁，只让一个它自己一个进程执行更新操作，可以保证强一致，但是会出现等待）
2. 只设置逻辑过期。（查到过期时，直接返回过期数据，再开一个另外的线程来更新（也用了互斥锁））

## 3. 缓存雪崩：是指大量带有ttl的数据在同一时间内消失。或是redis宕机。
方法：
1. 设置随机在原有过期时ttl，加个随机值。

宕机带来的问题解决方法：
1. 使用redis集群
2. 添加多级缓存Guava或其他

## 降级限流策略
可以在网关或是ngxin就是设置限流。是上面所有问题的保底策略。

## 缓存与数据库的一致性问题
不加锁进行数据库修改时，建议先改数据库，再延迟删缓存。对于延迟双删策略，我认为他的第一次删除是没有意义的。只要提出的解决方法都是在延迟删除的时候解决的。

# Redis本身特性
Redis有许多本身的特性，比如高速、独特数据类型、存储方式、无法根据value查key等等。想要一下子全部说完不容易，我只说部分：
## Redis单线程特性
redis在执行操作命令时是单线程的，所以可以利用Redis的单线程特性去解决超卖问题。

## Redis的持久化
1. RDB
2. AOF

懒得自己写了，内容可以参考这篇博客，还是写得挺详细的：
- https://blog.csdn.net/qq_61635026/article/details/132892150

## Redis为什么快？
“快”这个词，是一个相对的词。所以我以和MYsql进行对比的方式，说明一些他快的原因。
1. 基于内存（Mysql虽然也有内存，但它大部分数据存在磁盘，如何内存找不到数据，就会去磁盘找，而Redis只在内存找，找不到就是不存在。）
2. 省去了很多的操作：
- 它虽然采用单线程，但是也因为单线程，它可以少考虑很多因素。比如它**不需要考虑线程安全，不需要在执行时加锁**，也不需要向innodb一样弄一个MVCC机制，它啥都不需要，就是操作极简化。
- **不能回滚**，所以不需要向innodb一样弄一个快照。甚至因为这个原因，**Redis的事务是不能保证绝对原子性的**（它只能保证在出现语法错误时，全部不执行来一定程度上保证原子，但是遇到执行异常，他不能回滚，这种情况下它只能不执行后续操作，但是原子性已经没有了）

## Redis的lua脚本真的能保证绝对的原子性吗？
对于Redis事务无法回滚导致无法绝对保证原子性，这个网上经常能看到。而且还经常有人说Redis的lua脚本能狗保证原子性。但是却没看到多少人说lua怎么解决，我本来还以为lua真的能保证原子性，然后不明白那为什么那redis事务不用lua脚本做？

我在查阅了多篇相关文章后发现，其实lua脚本在出现执行异常时，也**不能**够保证绝对原子性的，**只能保证某条语句在语法错误时一起不执行**。而很多用lua脚本做的文件能保证绝对原子性，是因为在开发接口时，仔细检查和测试 Lua 脚本。所以它跟Redis事务在原子性的保证这一方面，其实一样。

_**版权声明：本文为博主原创文章，转载请附上原文出处链接和本声明。**_
