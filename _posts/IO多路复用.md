# IO多路复用
全都是我自己理解描述的，没有太多啰嗦话。

## 常见的网络IO模型：
1. **同步阻塞IO(BIO)**:在线程运行中，遇到IO操作，当前线程会被阻塞，直到IO处理完成，线程才接着处理后续流程。
2. **同步非阻塞IO(NIO)**:在线程处运行中，遇到IO操作，当前的线程不会被阻塞，而是继续处理其他业务代码，然后等过段时间再来确认IO交互是否完成。
3. **IO多路复用**。
4. **异步非阻塞IO(AIO)**:不是在IO准备好就马上线程，而是IO操作已经完成后，再通知。

其中AIO为异步IO，其他都是同步IO。

## IO多路复用

在网络传输的过程中，因为可能要同时处理非常多的请求，如果当需要处理的请求数比较多时，采用多线程的方式需要开启多个线程，这往往会导致频繁的切换上下文，上下文切换带来的开销过大。

而IO多路复用就是指：多个TCP连接（socket），复用指复用一个或几个线程。最大优势是减少系统开销小，不必创建过多的进程/线程，也不必维护这些进程/线程。

每个socket连接会生成一个FD，叫做文件描述符。
IO多路复用的3种实现方式：
1. select
2. poll
3. epoll

### select
select的处理方式，是默认使用1024个窗口，（我把他称为窗口，因为我觉得这样更好理解），可以用一个1024位的bitmap来实现（就绪标1）。当有新的连接就绪时，他们会被分配到这1024个窗口中的其中一个。然后有一个accept函数会一直遍历这1024个窗口，假设发现这个窗口有就绪的连接，就会去处理这个连接（称为**轮询**）。

fd文件类型有3种，三种类型分别是读、写、异常。

### poll
就是把窗口的概念去掉了，直接换成了一个长度可变的链表链表，链表节点记录了两个属性：1.是否就绪,2.fd类型（就是上面的3类fd）

然后又是遍历轮询这个链表。

### epoll
epoll不再依赖轮询。他的结构就有点类似于AQS。 有一个就绪链表和一个存储未就绪fd的红黑树。

每一个fd生成后，就会被加入到一个红黑树，并且给他分配一个监督器（就是回调函数），当他的状态就绪时，监听器（回调函数）就会把他放入就绪队列。

而当正在执行的IO处理完成后，就直接查就绪函数，不再需要轮询。

